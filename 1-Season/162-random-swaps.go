package main

import "fmt"

/*
https://www.cyberforum.ru/combinatorics/thread2408407.html

Алгоритм такой (полный перебор иначе брутфорс)
Генерируем К раз все возможные перестановки. Если n - Значность числа N, то кажная перестановка имеет m = C_n^2 возможностей. Все это удобно описывать n-значными числами в m-ичной системе исчисления. Перебор будет заключаться просто в прибавлении единицы.
В процессе перебора подсчитывать количество удачных и неудачных вариантов.
Трудоемкость алгоритма = mn
Правда, для некоторых чисел можно сразу сказать, что вероятность равна 0 (ну это, я думаю, вы сами прекрасно понимаете)
А десятку, да, можно сразу выбросить
Алгоритм слабо зависит от набора "любимых чисел"

Добавлено через 8 минут
Это действительно "тупой" алгоритм. Любимые числа 5 и 6 дают наводку на его существенную модификацию. Если в числе есть цифры 5, то для деления на него нужно всего лишь, чтобы она из них оказалась последней.
Если сумма цифр делится на 3 и есть несколько четных цифр, нас интересуют только те последовательности перестановок, которые на последнем действии дают в конце четную. Все это - одного поля ягоды. И алгоритм, менее грубый, существует. Но он достаточно тонок, и мне вот сейчас (ночь на дворе!) увидеть его не удается.

*/

func main() {
	var n, k int // целое число без нулей, количество операций над числом n
	fmt.Scan(&n, &k)
}
